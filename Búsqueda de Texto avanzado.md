


### üìò Tabla: `diccionario`

```sql
DROP TABLE diccionario;
CREATE TABLE diccionario (
    palabra TEXT NOT NULL
);

INSERT INTO diccionario (palabra)
VALUES 
    ('buscar'),
    ('buscado'),
    ('buscador'),
    ('buscando'),
    ('busca'),
    ('b√∫squeda'),
    ('busc√≥n'),
    ('buscaba'),
    ('busqu√©'),
    ('busquemos'),
    ('busc√°is'),
    ('busquen'),
    ('busco'),
    ('busqu√©is'),
    ('buscaste'),
    ('buscamos'),
    ('buscaban'),
    ('buscador'),
    ('buscadores'),
    ('buscadora'),
    ('buscadoras');

select * FROM diccionario;
```



# üîç 1. Usar `ILIKE` 

Se usa para coincidencia parcial (b√∫squeda b√°sica)

```sql

-- Obtendran 0 resultados ya que no hay ninguna palabra que dentro de su texto diga buscada
SELECT palabra FROM diccionario WHERE palabra ILIKE '%buscada%';

```

Esto busca cualquier palabra que contenga la cadena `"buscada"` sin importar may√∫sculas/min√∫sculas.




# üß† 2. Usar `SIMILARITY()`
requiere de  la extensi√≥n `pg_trgm` y sirve para (b√∫squeda por similitud)

### üîç ¬øC√≥mo funciona `similarity`?

Internamente, PostgreSQL:
1. **Divide cada texto en trigramas** (grupos de 3 caracteres).
2. **Calcula la intersecci√≥n y la uni√≥n** de los trigramas de ambos textos.
3. **Aplica la f√≥rmula de similitud**:

$$
\text{similarity}(A, B) = \frac{|\text{trigramas comunes}|}{|\text{trigramas totales (uni√≥n)}|}
$$

Este valor retorna un decimal entre **0** (nada en com√∫n) y **1** (id√©nticos).

### ¬øC√≥mo interpretar los resultados?

| Similitud | Interpretaci√≥n |
|-----------|----------------|
| 0.9 - 1.0 | Muy similares o casi iguales |
| 0.7 - 0.9 | Bastante similares |
| 0.4 - 0.7 | Algo similares |
| 0.0 - 0.4 | Poco o nada similares |

### Paso 1: Activar la extensi√≥n
```sql
CREATE EXTENSION IF NOT EXISTS pg_trgm;
```

### Paso 2: Buscar palabras similares
```sql
SELECT palabra, similarity(palabra, 'buscada') AS similitud
FROM diccionario
WHERE palabra % 'buscada'  -- operador de similitud
ORDER BY similitud DESC
LIMIT 5;

+----------+------------+
| palabra  | similitud  |
+----------+------------+
| buscado  |        0.6 |
| busca    |  0.5555556 |
| buscador | 0.54545456 |
| buscador | 0.54545456 |
| buscar   |        0.5 |
+----------+------------+
```

Esto te da las palabras m√°s parecidas a lo que el usuario escribi√≥, ordenadas por similitud.

### Puedes ajustar el umbral m√≠nimo para que el operador % funcione:
```
SET pg_trgm.similarity_threshold = 

postgres@postgres# select name,setting from pg_settings where name ilike '%trgm%';
+------------------------------------------+---------+
|                   name                   | setting |
+------------------------------------------+---------+
| pg_trgm.similarity_threshold             | 0.3     |
| pg_trgm.strict_word_similarity_threshold | 0.5     |
| pg_trgm.word_similarity_threshold        | 0.6     |
+------------------------------------------+---------+
(3 rows)
```




## üß™ 3. Usar `LEVENSHTEIN()` 

## üî¢ ¬øQu√© es la distancia de Levenshtein?

Es una **medida de diferencia** entre dos cadenas de texto. Representa el **n√∫mero m√≠nimo de operaciones necesarias** para transformar una cadena en otra. Las operaciones permitidas son:

1. **Inserci√≥n** de un car√°cter.
2. **Eliminaci√≥n** de un car√°cter.
3. **Sustituci√≥n** de un car√°cter.



### üìä Ejemplo pr√°ctico

Comparando `'gato'` con `'pato'`:

- Cambiar `'g'` por `'p'` ‚Üí 1 sustituci√≥n.

**Distancia de Levenshtein = 1**



### üîÅ Flujo de la funci√≥n

La funci√≥n sigue estos pasos:

1. **Inicializa una matriz** de tama√±o `(longitud de cadena A + 1) x (longitud de cadena B + 1)`.
2. **Llena la primera fila y columna** con valores incrementales (representan inserciones o eliminaciones).
3. **Compara cada car√°cter** de ambas cadenas.
4. **Calcula el costo m√≠nimo** entre:
   - Insertar un car√°cter.
   - Eliminar un car√°cter.
   - Sustituir un car√°cter (si son diferentes).
5. **Llena la matriz** con los valores m√≠nimos en cada paso.
6. **El valor final** en la esquina inferior derecha de la matriz es la distancia de Levenshtein.



### üß† ¬øPara qu√© sirve o Cu√°ndo usar levenshtein?

- **Correcci√≥n ortogr√°fica**: sugerir palabras similares.
- **B√∫squeda difusa o Sugerencias de texto**: encontrar coincidencias aproximadas.
- **Comparaci√≥n de nombres, direcciones, etc.** en bases de datos.


### Paso 1: Activar la extensi√≥n
```sql
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
```

### Paso 2: Buscar por distancia de edici√≥n
```sql
SELECT palabra, levenshtein(palabra, 'buscada') AS distancia
FROM diccionario
ORDER BY distancia ASC
LIMIT 5;
```
 
 
La forma **m√°s avanzada y precisa** de hacer b√∫squeda de palabras similares en PostgreSQL ‚Äîideal para una p√°gina web tipo buscador






--- 

# Usar soundex o Metaphone
Estos utiliza la Comparaci√≥n fon√©tica y requiere de la extensi√≥n fuzzystrmatch


## üîä ¬øC√≥mo funciona?

En lugar de comparar letras o trigramas como en la comparaci√≥n l√©xica, la comparaci√≥n fon√©tica convierte las palabras en **c√≥digos fon√©ticos** que representan c√≥mo suenan. Luego compara esos c√≥digos.

 

### üß∞ Algoritmos comunes

1. **Soundex**
   - Convierte palabras en un c√≥digo de 4 caracteres basado en su sonido.
   - Ejemplo: `'Ruiz'` y `'Ruis'` ‚Üí mismo c√≥digo Soundex.
   - Muy usado en bases de datos como SQL Server y tambi√©n disponible en PostgreSQL.

2. **Metaphone / Double Metaphone**
   - M√°s avanzado que Soundex.
   - Considera reglas fon√©ticas del ingl√©s.
   - Puede generar dos c√≥digos por palabra (por ejemplo, para nombres extranjeros).

3. **Cologne Phonetic (K√∂lner Phonetik)**
   - Adaptado para el idioma alem√°n.

 

### üìò Ejemplo en PostgreSQL con `Soundex`

```sql
SELECT palabra
FROM diccionario
WHERE soundex(palabra) = soundex('ruis');
```

Esto devolver√≠a palabras que suenan como `'ruis'`, aunque est√©n escritas diferente.

 

### üß† ¬øCu√°ndo usar comparaci√≥n fon√©tica?

- B√∫squeda de nombres en bases de datos (por ejemplo, `'Jon'`, `'John'`, `'Jhon'`).
- Correcci√≥n de errores de escritura por pronunciaci√≥n.
- Sistemas de b√∫squeda que deben tolerar errores humanos.

 
 
 
La diferencia entre **Metaphone** y **Soundex** radica en la **precisi√≥n fon√©tica**, el **idioma para el que fueron dise√±ados**, y la **forma en que codifican las palabras**. Aqu√≠ te explico cada uno:


## üîç Soundex

### ‚úÖ Caracter√≠sticas:
- **Dise√±ado para ingl√©s**.
- Convierte palabras en un c√≥digo de 4 caracteres:
  - La primera letra se conserva.
  - Las siguientes letras se convierten en n√∫meros seg√∫n grupos fon√©ticos.
  - Se eliminan vocales y letras repetidas.

### üìä Ejemplo:
- `'Ruiz'` ‚Üí `R200`
- `'Ruis'` ‚Üí `R200`  
  ‚Üí **Coinciden**, porque suenan igual.

### ‚ö†Ô∏è Limitaciones:
- Muy b√°sico.
- No distingue bien entre sonidos similares complejos.
- No funciona bien con nombres no ingleses.

 

## üîç Metaphone

### ‚úÖ Caracter√≠sticas:
- **M√°s avanzado que Soundex**.
- Considera reglas fon√©ticas m√°s precisas del ingl√©s.
- Codifica sonidos como `'F'`, `'K'`, `'S'`, `'X'`, etc.
- Elimina letras mudas y agrupa sonidos similares.

### üìä Ejemplo:
- `'Ruiz'` ‚Üí `RS`
- `'Ruis'` ‚Üí `RS`  
  ‚Üí Tambi√©n coinciden, pero con mejor precisi√≥n fon√©tica.

### üß† Ventajas:
- M√°s preciso para nombres y palabras con sonidos complejos.
- Mejora la b√∫squeda fon√©tica en bases de datos.

 

## üÜö Comparaci√≥n directa

| Caracter√≠stica        | Soundex         | Metaphone        |
|-----------------------|------------------|------------------|
| Precisi√≥n fon√©tica    | Baja              | Alta              |
| Longitud del c√≥digo   | Fija (4 caracteres) | Variable         |
| Idioma principal      | Ingl√©s            | Ingl√©s            |
| Manejo de letras mudas| No                | S√≠                |
| Uso en bases de datos | SQL Server, PostgreSQL | PostgreSQL, NLP |


### üîä Soundex
Esto busca palabras que **suenan como** `'buscada'` seg√∫n el algoritmo Soundex.

```sql
SELECT palabra, soundex(palabra) AS soundex_code
FROM diccionario
WHERE soundex(palabra) = soundex('buscada');
```
 
### üß† Metaphone
Esto busca palabras con **c√≥digos fon√©ticos similares** usando Metaphone (hasta 10 caracteres).

```sql
SELECT palabra, metaphone(palabra, 10) AS metaphone_code
FROM diccionario
WHERE metaphone(palabra, 10) = metaphone('buscada', 10);
```

---



----

# **Full Text Search (FTS)** en PostgreSQL; 


## ‚öôÔ∏è 2. Crear columna para `tsvector` (opcional pero recomendado)

```sql

-- Existe la opcion de no agregar una columna extra como palabra_vector y mejor dejarle el trabajo a el index para que  guardar toda la informaci√≥n.
-- ALTER TABLE diccionario ADD COLUMN palabra_vector tsvector GENERATED ALWAYS AS ( to_tsvector('spanish', palabra) ) STORED;

```



## üöÄ 3. Crear √≠ndice para b√∫squeda r√°pida

```sql
CREATE INDEX idx_diccionario_tsv ON diccionario USING GIN (to_tsvector('spanish', palabra));

-- Esta se usa en caso de de generar columna extra con GENERATED
-- CREATE INDEX idx_diccionario_tsv ON diccionario USING GIN (palabra_vector);

```

Este √≠ndice permite b√∫squedas eficientes con `@@`.



## üîç 4. Consultas con Full Text Search

### A. B√∫squeda b√°sica con `@@`

```sql
SELECT palabra
FROM diccionario
WHERE to_tsvector('spanish', palabra) @@ to_tsquery('spanish', 'buscado');
```

### B. B√∫squeda con operadores l√≥gicos

```sql
SELECT palabra
FROM diccionario
WHERE to_tsvector('spanish', palabra) @@ to_tsquery('spanish', 'buscar & r√°pido');
```

### C. B√∫squeda con prefijos (`:*`)

```sql
SELECT palabra
FROM diccionario
WHERE to_tsvector('spanish', palabra) @@ to_tsquery('spanish', 'busc:*');
```

Esto encuentra palabras que **empiezan con "busc"**.



## üß† Funciones m√°s usadas en FTS

| Funci√≥n | Descripci√≥n |
|--------|-------------|
| `to_tsvector('spanish', texto)` | Convierte texto en vector de b√∫squeda. |
| `to_tsquery('spanish', query)` | Convierte texto en consulta de b√∫squeda. |
| `plainto_tsquery('spanish', texto)` | Similar a `to_tsquery`, pero m√°s simple. |
| `ts_rank(tsvector, tsquery)` | Calcula relevancia de coincidencias. |
| `ts_headline('spanish', texto, tsquery)` | Resalta coincidencias en el texto. |



### üìä Ejemplo con `ts_rank`

```sql
SELECT palabra, ts_rank(to_tsvector('spanish', palabra), to_tsquery('spanish', 'buscador')) AS relevancia
FROM diccionario
WHERE to_tsvector('spanish', palabra) @@ to_tsquery('spanish', 'buscador')
ORDER BY relevancia DESC;
```
 
 
  

## üîÑ Flujo sem√°ntico de `to_tsvector` y `to_tsquery`

### üî∏ `to_tsvector('idioma', texto)`
**¬øQu√© hace?**
1. **Tokeniza** el texto (lo divide en palabras).
2. **Normaliza** las palabras (quita acentos, convierte a min√∫sculas).
3. **Elimina stopwords** (palabras comunes como ‚Äúel‚Äù, ‚Äúde‚Äù, ‚Äúy‚Äù).
4. **Devuelve un vector** con las palabras significativas y sus posiciones.

**Ejemplo:**
```sql
SELECT to_tsvector('spanish', 'La b√∫squeda de datos es importante');
-- Resultado: 'busqueda':2 'dato':3 'importante':5
```



### üî∏ `to_tsquery('idioma', consulta)`
**¬øQu√© hace?**
1. **Interpreta la consulta** como una expresi√≥n l√≥gica de b√∫squeda.
2. **Tokeniza y normaliza** igual que `to_tsvector`.
3. **Devuelve una estructura de b√∫squeda** que puede usarse con `@@`.

**Ejemplo:**
```sql
SELECT to_tsquery('spanish', 'busqueda & datos');
-- Resultado: 'busqueda' & 'dato'
```



### üîÅ ¬øC√≥mo se conectan?

```sql
SELECT texto
FROM tabla
WHERE to_tsvector('spanish', texto) @@ to_tsquery('spanish', 'busqueda & datos');

  
  SELECT to_tsvector('spanish', 'buscando'); -> 'busc':1 
  SELECT to_tsvector('spanish', 'buscando palabras en el texto'); --> 'busc':1 'palabr':2 'text':5
  
  select to_tsquery('spanish', 'buscado & biscado'); --> 'busc' & 'bisc' 
  SELECT plainto_tsquery('spanish', 'traducter'); -->  'traduct' 
 
  
  -- el numero que esta aun lado de la palabra es la posici√≥n 
  1.- buscando
  2.- palabras
  3.- en
  4.- el
  5.- texto
  
```

- `to_tsvector(...)` convierte el texto de la tabla en un vector.
- `to_tsquery(...)` convierte la consulta en una expresi√≥n l√≥gica.
- El operador `@@` verifica si el vector **cumple la condici√≥n sem√°ntica** de la consulta.



  

 --- 
 
 
  
### üõ†Ô∏è Script SQL: Crear tabla e insertar registros

```sql
CREATE TABLE articulos (
    id SERIAL PRIMARY KEY,
    titulo TEXT,
    resumen TEXT,
    contenido TEXT
);

INSERT INTO articulos (titulo, resumen, contenido) VALUES
('Seguridad en bases de datos', 'T√©cnicas de protecci√≥n de datos', 'La configuraci√≥n de seguridad en bases de datos es esencial para proteger la informaci√≥n confidencial.'),
('Configuraci√≥n avanzada de PostgreSQL', 'Ajuste de par√°metros de rendimiento', 'La configuraci√≥n de PostgreSQL permite optimizar el rendimiento y la seguridad del sistema.'),
('Introducci√≥n a la seguridad inform√°tica', 'Conceptos b√°sicos de ciberseguridad', 'La seguridad inform√°tica incluye pr√°cticas como el uso de firewalls, antivirus y pol√≠ticas de acceso.'),
('Bases de datos distribuidas', 'Distribuci√≥n de datos y seguridad', 'Las bases de datos distribuidas requieren una configuraci√≥n cuidadosa para garantizar la seguridad y la integridad.'),
('Auditor√≠a de seguridad en sistemas', 'Auditor√≠a en entornos cr√≠ticos', 'Una auditor√≠a de seguridad permite identificar vulnerabilidades en la configuraci√≥n de sistemas.'),
('Optimizaci√≥n de consultas SQL', 'Mejorar el rendimiento de las consultas', 'La optimizaci√≥n de consultas SQL puede reducir el tiempo de respuesta y mejorar la eficiencia del sistema.'),
('Seguridad en redes empresariales', 'Protecci√≥n de infraestructura de red', 'La seguridad en redes empresariales incluye segmentaci√≥n, monitoreo y control de acceso.'),
('Configuraci√≥n de firewalls', 'Uso de firewalls en seguridad', 'Los firewalls permiten controlar el tr√°fico de red y proteger los sistemas contra accesos no autorizados.'),
('Gesti√≥n de usuarios en bases de datos', 'Control de acceso y privilegios', 'La gesti√≥n de usuarios en bases de datos es clave para mantener la seguridad y evitar accesos indebidos.'),
('Cifrado de datos en tr√°nsito', 'Protecci√≥n de datos durante la transmisi√≥n', 'El cifrado de datos en tr√°nsito asegura que la informaci√≥n no sea interceptada por terceros.'),
('Seguridad en aplicaciones web', 'Prevenci√≥n de ataques comunes', 'La seguridad en aplicaciones web incluye protecci√≥n contra inyecciones SQL, XSS y CSRF.'),
('Monitoreo de sistemas', 'Supervisi√≥n continua de seguridad', 'El monitoreo de sistemas permite detectar actividades sospechosas y responder r√°pidamente a incidentes.'),
('Configuraci√≥n de roles en PostgreSQL', 'Asignaci√≥n de permisos y roles', 'La configuraci√≥n de roles en PostgreSQL permite definir permisos espec√≠ficos para cada usuario.'),
('Auditor√≠a de accesos', 'Registro de actividades de usuarios', 'La auditor√≠a de accesos permite rastrear qui√©n accede a qu√© recursos y cu√°ndo.'),
('Seguridad en la nube', 'Protecci√≥n de datos en entornos cloud', 'La seguridad en la nube requiere cifrado, autenticaci√≥n fuerte y monitoreo constante.'),
('Configuraci√≥n de backups seguros', 'Respaldo y recuperaci√≥n de datos', 'Los backups seguros garantizan la disponibilidad de datos ante fallos o ataques.'),
('Seguridad en dispositivos m√≥viles', 'Protecci√≥n de datos en smartphones', 'La seguridad en dispositivos m√≥viles incluye cifrado, autenticaci√≥n y control remoto.'),
('Pruebas de penetraci√≥n', 'Evaluaci√≥n de vulnerabilidades', 'Las pruebas de penetraci√≥n permiten identificar debilidades en la configuraci√≥n de seguridad.'),
('Seguridad en entornos virtualizados', 'Protecci√≥n de m√°quinas virtuales', 'La seguridad en entornos virtualizados requiere aislamiento, monitoreo y control de acceso.'),
('Configuraci√≥n de autenticaci√≥n multifactor', 'Mejorar la seguridad de acceso', 'La autenticaci√≥n multifactor agrega una capa adicional de seguridad al proceso de inicio de sesi√≥n.');
```
 
 
 

## üß† Explicaci√≥n detallada de funciones clave

### üîπ `phraseto_tsquery()`
**¬øQu√© hace?**  
Busca **frases exactas** en el texto, es decir, que las palabras aparezcan **juntas y en el mismo orden**.

**¬øCu√°ndo usarla?**  
Cuando necesitas precisi√≥n, por ejemplo: `"configuraci√≥n de seguridad"` debe aparecer como una frase, no solo como palabras separadas.

**¬øCon qu√© se combina?**  
- `to_tsvector()` para convertir el texto a formato buscable.
- `@@` para aplicar la b√∫squeda.
- `ts_rank()` para medir relevancia.
- `ts_headline()` para mostrar resultados resaltados.

**Ejemplo:**
```sql
SELECT * 
FROM articulos 
WHERE to_tsvector(contenido) @@ phraseto_tsquery('configuraci√≥n de seguridad');
```

---

### üîπ `ts_headline()`
**¬øQu√© hace?**  
Resalta los t√©rminos encontrados en el texto, √∫til para mostrar fragmentos como en un buscador.

**¬øCu√°ndo usarla?**  
Cuando presentas resultados al usuario y quieres mostrar **d√≥nde** se encontr√≥ la coincidencia.

**¬øCon qu√© se combina?**  
- `to_tsquery()` o `phraseto_tsquery()` para definir la b√∫squeda.
- `to_tsvector()` para preparar el texto.
- `@@` para filtrar resultados.

**Ejemplo:**
```sql
SELECT ts_headline('spanish', contenido, phraseto_tsquery('configuraci√≥n de seguridad')) 
FROM articulos 
WHERE to_tsvector(contenido) @@ phraseto_tsquery('configuraci√≥n de seguridad');
```

---

### üîπ `setweight()`
**¬øQu√© hace?**  
Asigna **prioridad** a diferentes columnas en el `tsvector`. Por ejemplo, el t√≠tulo puede tener m√°s peso que el contenido.

**¬øCu√°ndo usarla?**  
Cuando combinas varias columnas en la b√∫squeda y quieres que algunas influyan m√°s en la relevancia.

**¬øCon qu√© se combina?**  
- `to_tsvector()` para cada columna.
- `ts_rank()` para que el peso influya en el c√°lculo de relevancia.

**Ejemplo:**
```sql
SELECT setweight(to_tsvector(titulo), 'A') || 
       setweight(to_tsvector(resumen), 'B') || 
       setweight(to_tsvector(contenido), 'C') AS documento
FROM articulos;
```

---

### üîπ `ts_rank()`
**¬øQu√© hace?**  
Calcula un **puntaje de relevancia** para cada documento seg√∫n qu√© tan bien coincide con la consulta.

**¬øCu√°ndo usarla?**  
Cuando quieres **ordenar los resultados** por relevancia, como en un motor de b√∫squeda.

**¬øCon qu√© se combina?**  
- `setweight()` para ponderar columnas.
- `to_tsquery()` o `phraseto_tsquery()` para definir la b√∫squeda.
- `@@` para filtrar resultados.

**Ejemplo completo:**
```sql
SELECT titulo,
       ts_rank(
         setweight(to_tsvector(titulo), 'A') || 
         setweight(to_tsvector(resumen), 'B') || 
         setweight(to_tsvector(contenido), 'C'),
         phraseto_tsquery('configuraci√≥n de seguridad')
       ) AS relevancia,
       ts_headline('spanish', contenido, phraseto_tsquery('configuraci√≥n de seguridad')) AS resumen_destacado
FROM articulos
WHERE to_tsvector(titulo || ' ' || resumen || ' ' || contenido) @@ phraseto_tsquery('configuraci√≥n de seguridad')
ORDER BY relevancia DESC;
```



--- 

# Extra ejemplo  B√∫squeda avanzada sem√°ntica y fon√©tica 

### 1. **Extensiones necesarias**
Activa estas extensiones en PostgreSQL:

```sql
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
```



### 2. **Crear √≠ndice para acelerar b√∫squedas**
Esto mejora el rendimiento de b√∫squedas por similitud:

```sql
CREATE INDEX idx_palabra_trgm ON diccionario USING gin (palabra gin_trgm_ops);
```

### 3. **Consulta avanzada combinando similitud y fon√©tica**

```sql
SELECT palabra,
       similarity(palabra, 'buscada') AS similitud,
       levenshtein(lower(palabra), lower('buscada')) AS distancia,
       soundex(palabra) = soundex('buscada') AS foneticamente_similar
FROM diccionario
WHERE palabra % 'buscada'  -- operador de similitud
ORDER BY similitud DESC, distancia ASC
LIMIT 5;
```

### ¬øQu√© hace esto?

- `similarity()`: mide qu√© tan parecida es la palabra.
- `levenshtein()`: mide cu√°ntos cambios se necesitan para convertir una palabra en otra.
- `soundex()`: compara c√≥mo suenan las palabras (√∫til para errores de escritura fon√©tica).
- `palabra % 'buscada'`: usa el operador de similitud de `pg_trgm`.


---


## üîç Tabla Comparativa de Herramientas de B√∫squeda de Texto

| Tecnolog√≠a         | ¬øQu√© hace?                          | ¬øCu√°ndo usarla?                     | Precisi√≥n | Velocidad | Ideal para                        |
|-------------------|-------------------------------------|-------------------------------------|-----------|-----------|-----------------------------------|
| `pg_trgm`         | B√∫squeda por similitud de texto     | Correcci√≥n ortogr√°fica, sugerencias | Alta      | Muy alta  | Errores ortogr√°ficos, sugerencias |
| `LIKE` / `ILIKE`  | Coincidencia exacta o parcial       | B√∫squeda simple                     | Media     | Muy alta  | Filtros r√°pidos y directos        |
| `tsvector`        | Indexaci√≥n sem√°ntica                | B√∫squeda contextual                 | Alta      | Alta      | B√∫squeda sem√°ntica contextual     |
| `tsquery`         | Consulta sem√°ntica avanzada         | Filtros por significado             | Alta      | Alta      | B√∫squeda con operadores l√≥gicos   |
| `fuzzystrmatch`   | Comparaci√≥n fon√©tica                | Nombres mal escritos                | Media     | Media     | Comparaci√≥n l√©xica y fon√©tica     |

---

## üß† Glosario de t√©rminos t√©cnicos

### 1. **Similitud**
- **Definici√≥n**: Medida que indica qu√© tan parecidos son dos textos.
- **Ejemplo**: `'buscado'` y `'buscador'` tienen alta similitud porque comparten muchas letras en el mismo orden.
- **En PostgreSQL**: La funci√≥n `similarity(text1, text2)` devuelve un valor entre 0 y 1.

---

### 2. **Distancia**
- **Definici√≥n**: Medida de cu√°n diferentes son dos textos.
- **Tipos comunes**:
  - **Levenshtein**: N√∫mero m√≠nimo de ediciones (inserciones, eliminaciones, sustituciones) para transformar un texto en otro.
  - **Jaccard**: Basada en la intersecci√≥n y uni√≥n de conjuntos de trigramas.
- **Relaci√≥n con similitud**: A mayor distancia, menor similitud.

---

### 3. **Trigrama**
- **Definici√≥n**: Secuencia de tres caracteres consecutivos en un texto.
- **Ejemplo**: Para `'buscada'`, los trigramas son `bus`, `usc`, `sca`, `cad`, `ada`.
- **Uso en `pg_trgm`**: PostgreSQL compara trigramas para calcular similitud.

---

### 4. **Operador `%`**
- **Definici√≥n**: Operador de similitud en PostgreSQL.
- **Funci√≥n**: Filtra registros que son "suficientemente similares" al texto buscado.
- **Ejemplo**: `palabra % 'buscada'` devuelve palabras con similitud mayor al umbral.

---

### 5. **B√∫squeda sem√°ntica**
- **Definici√≥n**: Busca entender el significado del texto, no solo su forma.
- **Ejemplo**: `'auto'` y `'veh√≠culo'` pueden considerarse similares aunque no compartan letras.
- **Nota**: PostgreSQL no hace b√∫squeda sem√°ntica nativa, pero se puede integrar con herramientas como embeddings o modelos NLP.

### La **comparaci√≥n fon√©tica** 
es una t√©cnica que busca determinar si dos palabras **suenan parecido**, 
aunque est√©n escritas de forma diferente. Es muy √∫til en sistemas de b√∫squeda, correcci√≥n ortogr√°fica o bases de datos donde los nombres pueden tener errores de escritura pero conservar una pronunciaci√≥n similar.


---

### 6. **Comparaci√≥n l√©xica**
- **Definici√≥n**: Comparaci√≥n basada en la forma textual (letras, orden, longitud).
- **Ejemplo**: `'casa'` y `'casas'` son l√©xicamente similares.
- **Uso**: Es la base de `pg_trgm`, `LIKE`, `ILIKE`, y operadores de texto.

---

### 7. **Umbral de similitud (`pg_trgm.similarity_threshold`)**
- **Definici√≥n**: Valor m√≠nimo para que el operador `%` considere dos textos como similares.
- **Ejemplo**: Si el umbral es `0.4`, solo se consideran similares los textos con `similarity >= 0.4`.

----

### üîπ **Vector (tsvector)**
- En FTS, un **vector** es una estructura que representa un texto como un conjunto de **tokens indexables**.
- Cada token es una palabra significativa (sin stopwords) y puede incluir su **posici√≥n** en el texto.
- Ejemplo:  
  ```sql
  SELECT to_tsvector('spanish', 'buscando palabras en texto');
  ```
  Resultado:
  ```
  'buscando':1 'palabra':2 'texto':4
  ```

--- 

### üîπ **Dimensiones**
- En el contexto de FTS, cada **palabra indexada** puede considerarse una **dimensi√≥n** del espacio vectorial.
- El texto se transforma en un vector que vive en un espacio donde cada dimensi√≥n representa una palabra.
- Esto permite comparar vectores (textos) usando operaciones como `@@` o `ts_rank`.


### üîπ **calcular la relevancia** 
de las coincidencias en una b√∫squeda de texto completo. Es decir, **asigna un puntaje** que indica qu√© tan bien un documento (o texto) coincide con una consulta de b√∫squeda.

### ¬øQu√© significa "relevancia de coincidencias"?

Cuando haces una b√∫squeda de texto completo con `to_tsvector` y `to_tsquery`, puedes encontrar varios documentos que contienen las palabras buscadas. Pero no todos los documentos son igual de relevantes. Por ejemplo:

- Un documento que contiene todas las palabras buscadas varias veces puede ser m√°s relevante.
- Un documento donde las palabras aparecen cerca unas de otras tambi√©n puede ser m√°s relevante.
- Un documento que solo contiene una palabra buscada una vez puede ser menos relevante.


### Bibliograf√≠a
```
https://medium.com/the-table-sql-and-devtalk/mastering-postgresql-full-text-search-a-definitive-guide-a794b47dfcbf
pgvector -> https://github.com/CR0NYM3X/POSTGRESQL/blob/main/Extensiones/pgvector.md
```
