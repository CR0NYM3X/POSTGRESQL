
 ## Comandos usados en OpenSSL
 ```
### Ver version de openssl y las rutas kpi 
openssl version -a 

### Ver todos los algoritmos que se pueden usar 
openssl ciphers -v | column -t |  grep "1.3"

### Excluyes algoritmos 
openssl ciphers -v 'ALL:!MD5:!3DES:!RC4:!DES:!IDEA:!RC2' | column -t
openssl ciphers -v 'MD5:RC4:3DES:DES:IDEA:RC2:SHA1:NULL:aNULL:EXP'
openssl ciphers -v 'RC4-MD5:RC4-SHA:DES-CBC3-SHA:IDEA-CBC-SHA:RC2-CBC-MD5:EXP-RC4-MD5:EXP-DES-CBC-SHA:NULL-MD5:NULL-SHA:MD5'
 ```



## Validar las conexiones
 ```
openssl s_client -connect 172.10.10.100:5416 -starttls postgres -tls1_3 -ciphersuites TLS_AES_256_GCM_SHA384  -CAfile  combined.crt -verify_return_error -tlsextdebug -status  -showcerts
openssl s_client -connect 127.0.0.1:5416 -starttls postgres -tls1_2 -cert /tmp/pki/certs/client_new.crt -key /tmp/pki/private/client_new.key -CAfile /tmp/pki/CA/ca-chain.crt


 Parámetro                     ¿Qué hace?                                                                 
----------------------------------------------------------------------------------------------------------
 `-connect host:port`         Especifica la dirección y puerto del servidor al que deseas conectarte     
 `-starttls protocolo`        Inicia un *handshake* TLS para protocolos como `postgres`, `smtp`, `ftp`   
 `-tls1_2`, `-tls1_3`         Fuerza la versión de TLS que deseas usar en la conexión                    
 `-ciphersuites`              >= tls1.3 Seleccionas  explícitamente cual cipher suites usar , Ejemplo ->   TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256             
 `-cipher`                    <= 1.2 aqui filtras los cipher suites. Ejemplo -> 'HIGH:!aNULL:!MD5:!3DES:!RC4:!DES:!IDEA:!RC2'                
 `-CAfile archivo.crt`        Usa certificados raíz/intermedios para validar el certificado del servidor 
 `-verify_return_error`       Falla la conexión si no se puede verificar el certificado                   
 `-showcerts`                 Muestra todos los certificados entregados por el servidor                  
 `-servername nombre`         Establece el SNI (Server Name Indication), útil si el servidor tiene múltiples dominios 
 `-quiet`                     Silencia detalles del protocolo para una salida más limpia
 `-brief`                      mostrar una salida más concisa y enfocada durante la simulación de una conexión TLS/SSL. En lugar de imprimir todo el certificado, la cadena completa

 ```


 

## 🚫 Algoritmos inseguros en TLS 1.2 que debes excluir

| 🔑 Algoritmo / Cipher Suite             | ❌ ¿Por qué evitarlo?                          |
|----------------------------------------|-----------------------------------------------|
| `RC4`                                  | Vulnerable a ataques de sesgo en el cifrado   |
| `3DES` (`Triple DES`)                  | Tiene solo 112 bits efectivos — débil         |
| `MD5`                                  | Algoritmo hash roto — susceptible a colisiones|
| `SHA1`                                 | Débil frente a ataques de colisión            |
| `DES`, `IDEA`, `RC2`                   | Cifrados antiguos y fácilmente rompibles      |
| `NULL`, `aNULL`, `EXP`                 | No cifran o permiten autenticación nula       |
| `CBC` sin AEAD (como `AES_128_CBC`)    | Vulnerable a ataques como BEAST y Lucky13     |

---

## 🛡️ ¿Cómo excluirlos en en PostgreSQL?

Puedes usar el parámetro 
 ```
ssl_prefer_server_ciphers = on
ssl_ciphers =  'HIGH:!MD5:!RC4:!3DES:!DES:!IDEA:!RC2:!SHA1:!NULL:!aNULL:!EXP'
 ```


### Validar  todos los algorimos debiles manualmente 
```
openssl s_client -connect 127.0.0.1:5416 -starttls postgres -cipher 'RC4-MD5:RC4-SHA:DES-CBC3-SHA:IDEA-CBC-SHA:RC2-CBC-MD5:EXP-RC4-MD5:EXP-DES-CBC-SHA:NULL-MD5:NULL-SHA:MD5'
openssl s_client -connect 127.0.0.1:5416 -starttls postgres -cipher 'RC4-MD5:RC4-SHA:DES-CBC3-SHA:IDEA-CBC-SHA:RC2-CBC-MD5:EXP-RC4-MD5:EXP-DES-CBC-SHA:NULL-MD5:NULL-SHA:MD5'
```


## Herramienta para automatizar la validación de cada ciphers suite
```
#!/bin/bash

# 💡 Lista de cipher suites inseguros (solo TLS 1.2 y anteriores)
# ⚠️ TLS 1.3 no admite estas suites, por eso se fuerza TLS 1.2
# Nueva version que valide si puede conectarse con diferentes versiones de tls 1.0,1.1,1.2 y 1.3 y tambien que valide si se puede conectar con algoritmos vulnerables
# detecta los algoritmos >= 1.3 y usa ciphersuites y cuando son <= 1.2 usa cipher

TARGET="127.0.0.1:5416"
PROTOCOL="postgres"
## BAD_CIPHERS="RC4-MD5 RC4-SHA DES-CBC3-SHA IDEA-CBC-SHA RC2-CBC-MD5 EXP-RC4-MD5 EXP-DES-CBC-SHA NULL-MD5 NULL-SHA MD5"
## BAD_CIPHERS=$(openssl ciphers 'MD5:3DES:RC4:DES:IDEA:RC2' |  tr ':' ' ')
BAD_CIPHERS=$(openssl ciphers |  tr ':' ' ')


echo "🔍 Iniciando auditoría de cipher suites inseguros contra $TARGET usando protocolo STARTTLS ($PROTOCOL)"
echo "---------------------------------------------------------------"
echo ""

for CIPHER in $BAD_CIPHERS; do
  echo "🔧 Probando cipher inseguro: $CIPHER"

  RESULT=$(echo | openssl s_client -connect $TARGET -starttls $PROTOCOL -ciphersuites $CIPHER -brief 2>&1)
 
  NEGOTIATED=$(echo "$RESULT" | grep "^Cipher" | awk '{print $2}')
  PROTOCOL_USED=$(echo "$RESULT" | grep "^Protocol" | awk '{print $3}')

  if [[ -n "$NEGOTIATED" ]]; then
    echo "❌ 🔥 Cipher NEGOCIADO: $NEGOTIATED (Protocolo: $PROTOCOL_USED)"
	echo "Comando: echo | openssl s_client -connect $TARGET -starttls $PROTOCOL -ciphersuites $CIPHER -brief 2>&1"
  else
    echo "✅ Cipher rechazado — el servidor no lo acepta"
	echo "Comando: echo | openssl s_client -connect $TARGET -starttls $PROTOCOL -ciphersuites $CIPHER -brief 2>&1"
  fi
  
  echo "---------------------------------------------------------------"
done

echo "✅ Auditoría completada."
```
