### üîç **Causas por las que un slot puede estar reteniendo mucho WAL**

1. **üìâ Replicaci√≥n lenta o pausada**
   - El proceso que consume el slot (como Debezium, pglogical, etc.) est√° funcionando lentamente o est√° detenido.
   - Esto hace que PostgreSQL no pueda eliminar los WAL antiguos, ya que el slot a√∫n los necesita.

2. **‚è∏Ô∏è Slot inactivo**
   - El slot est√° definido pero **no tiene un consumidor activo** (`active = false`).
   - PostgreSQL seguir√° reteniendo WAL indefinidamente, lo que puede llenar el disco si no se gestiona.

3. **üîÅ Transacciones largas**
   - Si el consumidor del slot est√° procesando una transacci√≥n muy larga, el `restart_lsn` no avanza hasta que se confirme.
   - Esto puede causar acumulaci√≥n de WAL.

4. **üß± Problemas de red o conectividad**
   - Si el sistema que consume el slot est√° en otra red o nube y tiene problemas de conexi√≥n, puede retrasarse en leer los datos.

5. **‚öôÔ∏è Configuraci√≥n incorrecta**
   - No se han definido l√≠mites o alertas para el tama√±o del WAL retenido.
   - No se est√°n monitoreando los slots activamente.
  
### üõ†Ô∏è ¬øC√≥mo evitar que un slot se vuelva pesado?

- Monitorea regularmente el `restart_lsn` y comp√°ralo con `pg_current_wal_lsn()`.
- Elimina slots inactivos con `SELECT pg_drop_replication_slot('slot_name');` si ya no se usan.
- Aseg√∫rate de que el consumidor est√© activo y procesando datos.
- Usa herramientas como `pg_stat_replication` para ver el estado de los consumidores.
- Configura alertas si el WAL retenido supera cierto umbral (por ejemplo, 1 GB).


## üß† An√°lisis de cada funci√≥n

| Funci√≥n | ¬øQu√© mide? | ¬øSirve para medir retraso? | ¬øPor qu√©? |
|--------|-------------|----------------------------|-----------|
| `pg_current_wal_lsn()` | √öltimo LSN visible en el sistema | ‚úÖ S√≠ | Representa el punto m√°s avanzado del WAL que el sistema reconoce. |
| `pg_current_wal_insert_lsn()` | √öltimo LSN insertado en el WAL (a√∫n no escrito) | ‚ö†Ô∏è No recomendado | Puede incluir datos a√∫n no visibles ni comprometidos. |
| `pg_current_wal_flush_lsn()` | √öltimo LSN confirmado como escrito en disco | ‚úÖ S√≠ | Representa el punto seguro y duradero del WAL. |


 # Ver retraso de replica standby en KB
 ```
-- Puedes calcular cu√°ntos bytes y  calcular el tama√±o del WALs retenido y que puedes dividir entre 1024 para obtener KB.
--  DBAs avanzados prefieren confirmed_flush_lsn para monitoreo en tiempo real.

SELECT
    slot_name,
    plugin,
    slot_type,
    active,
    pg_current_wal_flush_lsn() AS current_flush_lsn,
    confirmed_flush_lsn,
    pg_current_wal_flush_lsn() - confirmed_flush_lsn AS wal_lag_bytes
FROM 
    pg_replication_slots
WHERE 
    confirmed_flush_lsn IS NOT NULL;

-- Administradores de infraestructura usan restart_lsn para evitar problemas de almacenamiento.
SELECT slot_name, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(),restart_lsn)) AS lag, active from pg_replication_slots WHERE slot_type='logical';



```

# Otras validaciones
```
-- Verifica si el plugin wal2json est√° instalado
rpm -qla | grep wal2json

-- Verifica si hay procesos de replicaci√≥n activos
SELECT * FROM pg_stat_wal_receiver; --- comando para ver lo que se recibe y saber cual es el servidor principal
SELECT * FROM pg_stat_replication;  --- comando para ver en el serv principal las ip serv soporte y ver la columna sync_state  puede tener el valor  async  y sync
SELECT slot_name, spill_txns, spill_count, spill_bytes, total_txns, total_bytes FROM pg_stat_replication_slots;



-- Si retorna true, significa que el servidor est√° en modo standby (r√©plica).
-- Si retorna false, significa que el servidor es el primario y acepta escrituras
select pg_is_in_recovery();


-- Verifica si hay slots de replicaci√≥n l√≥gica activos
SELECT slot_name, plugin, slot_type, active, active_pid FROM pg_replication_slots;

	slot_type = physical ‚Üí R√©plica f√≠sica (streaming)
	slot_type = logical ‚Üí R√©plica l√≥gica
	plugin = wal2json o pgoutput ‚Üí L√≥gica
	plugin = (null) ‚Üí F√≠sica

SELECT slot_name, spill_txns, spill_count, spill_bytes, total_txns, total_bytes FROM pg_stat_replication_slots;

-- Verifica si hay procesos de replicaci√≥n activos
SELECT * FROM pg_stat_wal_receiver; --- comando para ver lo que se recibe y saber cual es el servidor principal
SELECT * FROM pg_stat_replication;  --- comando para ver en el serv principal las ip serv soporte y ver la columna sync_state  puede tener el valor  async  y sync
	write_lag -> Indica cu√°nto tiempo tarda la r√©plica en escribir los datos del WAL que recibe desde el primario.
	flush_lag -> Indica cu√°nto tiempo tarda la r√©plica en flushear (asegurar en disco) los datos del WAL que ya ha escrito. 
	replay_lag ->  Indica cu√°nto tiempo tarda la r√©plica en aplicar los cambios del WAL a las tablas, es decir, que los datos sean realmente visibles para las consultas.

ps -fea | grep walreceiver
ps -fea | grep walsender
ps -fea | grep stream



-- ver los archivos WAL presentes en el servidor
SELECT name,pg_size_pretty(sum(size)) AS size,modification FROM pg_ls_waldir() group by  name,modification;

select * from pg_stat_activity 
select * from pg_stat_progress_basebackup;
SELECT CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn()   THEN 0  ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp()) END AS log_delay;

SELECT pid, usename, application_name, state
, pg_current_wal_lsn() AS current_lsn
, sent_lsn
, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn)) AS sent_diff
, write_lsn
, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn)) AS write_diff
, replay_lsn
, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS replay_diff
, write_lag, flush_lag, replay_lag
FROM pg_stat_replication
ORDER BY application_name, pid;



select specific_schema, routine_name  from  information_schema.routines  where routine_name ilike '%wal%';
| pg_catalog      | pg_stat_get_wal_senders       |
| pg_catalog      | pg_stat_get_wal_receiver      |
| pg_catalog      | pg_stat_get_wal               |
| pg_catalog      | pg_current_wal_lsn            |
| pg_catalog      | pg_current_wal_insert_lsn     |
| pg_catalog      | pg_current_wal_flush_lsn      |
| pg_catalog      | pg_walfile_name_offset        |
| pg_catalog      | pg_walfile_name               |
| pg_catalog      | pg_split_walfile_name         |
| pg_catalog      | pg_wal_lsn_diff               |
| pg_catalog      | pg_last_wal_receive_lsn       |
| pg_catalog      | pg_last_wal_replay_lsn        |
| pg_catalog      | pg_is_wal_replay_paused       |
| pg_catalog      | pg_get_wal_replay_pause_state |
| pg_catalog      | pg_get_wal_resource_managers  |
| pg_catalog      | pg_switch_wal                 |
| pg_catalog      | pg_wal_replay_pause           |
| pg_catalog      | pg_wal_replay_resume          |
| pg_catalog      | pg_ls_waldir                  |


select * from pg_control_checkpoint();

```


### üìã **Funcion de `pg_control_checkpoint()`**

| **Columna**               | **Descripci√≥n** |
|---------------------------|-----------------|
| `checkpoint_lsn`          | LSN donde se escribi√≥ el √∫ltimo checkpoint en el WAL. |
| `redo_lsn`                | LSN desde donde debe comenzar la recuperaci√≥n si hay fallo. Puede ser anterior al `checkpoint_lsn`. |
| `redo_wal_file`           | Archivo WAL que contiene el `redo_lsn`. √ötil para identificar qu√© archivo se necesita para recuperaci√≥n. |
| `timeline_id`             | ID de la l√≠nea de tiempo actual. Cambia en eventos como failover. |
| `prev_timeline_id`        | ID de la l√≠nea de tiempo anterior. |
| `full_page_writes`        | Indica si se est√°n escribiendo p√°ginas completas en el WAL (`t` = true). Mejora la recuperaci√≥n ante fallos. |
| `next_xid`                | Pr√≥ximo ID de transacci√≥n que se asignar√°. |
| `next_oid`                | Pr√≥ximo OID (Object Identifier) que se asignar√° a objetos como tablas. |
| `next_multixact_id`       | Pr√≥ximo ID de multitransacci√≥n (usado en bloqueos compartidos). |
| `next_multi_offset`       | Offset dentro del multixact actual. |
| `oldest_xid`              | ID de transacci√≥n m√°s antigua que a√∫n puede afectar el sistema (usado para VACUUM). |
| `oldest_xid_dbid`         | ID de la base de datos que contiene el `oldest_xid`. |
| `oldest_active_xid`       | ID de la transacci√≥n activa m√°s antigua. |
| `oldest_multi_xid`        | ID de multitransacci√≥n m√°s antigua a√∫n relevante. |
| `oldest_multi_dbid`       | ID de la base de datos que contiene el `oldest_multi_xid`. |
| `oldest_commit_ts_xid`    | ID de transacci√≥n m√°s antigua con marca de tiempo de commit. |
| `newest_commit_ts_xid`    | ID de transacci√≥n m√°s reciente con marca de tiempo de commit. |
| `checkpoint_time`         | Fecha y hora en que se realiz√≥ el √∫ltimo checkpoint. |

 
## üìä Tabla `pg_replication_slots`

Esta tabla contiene informaci√≥n sobre los **slots de replicaci√≥n**, que son mecanismos para retener WAL hasta que los consumidores (como r√©plicas o procesos de an√°lisis) lo hayan le√≠do.

### üìå Descripci√≥n de columnas

| Columna | Tipo | Descripci√≥n |
|--------|------|-------------|
| `slot_name` | `name` | Nombre √∫nico del slot de replicaci√≥n. |
| `plugin` | `name` | Nombre del plugin usado (solo en replicaci√≥n l√≥gica). |
| `slot_type` | `text` | Tipo de slot: `physical` o `logical`. |
| `datoid` | `oid` | OID de la base de datos asociada (solo en l√≥gica). |
| `database` | `name` | Nombre de la base de datos (solo l√≥gica). |
| `temporary` | `boolean` | Si el slot es temporal (se elimina al cerrar la sesi√≥n). |
| `active` | `boolean` | Si el slot est√° siendo usado actualmente. |
| `active_pid` | `integer` | PID del proceso que lo est√° usando (si est√° activo). |
| `xmin` | `xid` | M√≠nimo XID retenido por el slot (solo l√≥gica). |
| `catalog_xmin` | `xid` | M√≠nimo XID del cat√°logo retenido (solo l√≥gica). |
| `restart_lsn` | `pg_lsn` | Punto desde el cual se puede reiniciar la replicaci√≥n. |
| `confirmed_flush_lsn` | `pg_lsn` | √öltimo LSN confirmado por el consumidor (solo l√≥gica). |

 
 
## üìä Tabla: `pg_stat_wal_receiver`

Esta vista muestra el estado del proceso que **recibe los WAL desde el servidor primario** en una r√©plica f√≠sica.

### üìå Descripci√≥n de columnas

| Columna | Tipo | Descripci√≥n |
|--------|------|-------------|
| `pid` | `integer` | ID del proceso del receptor WAL. |
| `status` | `text` | Estado actual del receptor (`streaming`, `stopped`, etc.). |
| `receive_start_lsn` | `pg_lsn` | LSN donde comenz√≥ a recibir datos. |
| `receive_start_tli` | `integer` | Timeline ID donde comenz√≥ la recepci√≥n. |
| `written_lsn` | `pg_lsn` | √öltimo LSN escrito en disco por el receptor. |
| `flushed_lsn` | `pg_lsn` | √öltimo LSN confirmado como escrito en disco. |
| `received_lsn` | `pg_lsn` | √öltimo LSN recibido desde el primario. |
| `latest_end_lsn` | `pg_lsn` | √öltimo LSN reportado por el primario como disponible. |
| `latest_end_time` | `timestamp with time zone` | Hora del √∫ltimo LSN disponible en el primario. |
| `slot_name` | `text` | Nombre del slot de replicaci√≥n usado (si aplica). |
| `sender_host` | `text` | IP o hostname del servidor primario. |
| `sender_port` | `integer` | Puerto del servidor primario. |
| `conninfo` | `text` | Cadena de conexi√≥n usada para conectarse al primario. |
| `sync_priority` | `integer` | Prioridad de sincronizaci√≥n (si hay m√∫ltiples r√©plicas). |
| `sync_state` | `text` | Estado de sincronizaci√≥n: `async`, `sync`, `quorum`. |



## üìä Tabla: `pg_stat_replication`

Esta vista muestra el estado de las **r√©plicas conectadas al servidor primario**.

### üìå Descripci√≥n de columnas

| Columna | Tipo | Descripci√≥n |
|--------|------|-------------|
| `pid` | `integer` | ID del proceso de backend que maneja la r√©plica. |
| `usesysid` | `oid` | ID del rol que inici√≥ la conexi√≥n de replicaci√≥n. |
| `usename` | `name` | Nombre del rol que inici√≥ la conexi√≥n. |
| `application_name` | `text` | Nombre de la aplicaci√≥n (configurado en `primary_conninfo`). |
| `client_addr` | `inet` | Direcci√≥n IP del cliente (r√©plica). |
| `client_hostname` | `text` | Hostname del cliente (si est√° disponible). |
| `client_port` | `integer` | Puerto del cliente. |
| `backend_start` | `timestamp with time zone` | Hora en que se inici√≥ el proceso de backend. |
| `backend_xmin` | `xid` | M√≠nimo XID retenido por el backend (replicaci√≥n l√≥gica). |
| `state` | `text` | Estado actual: `streaming`, `catchup`, `startup`, etc. |
| `sent_lsn` | `pg_lsn` | √öltimo LSN enviado al cliente. |
| `write_lsn` | `pg_lsn` | √öltimo LSN escrito por el cliente. |
| `flush_lsn` | `pg_lsn` | √öltimo LSN confirmado como escrito por el cliente. |
| `replay_lsn` | `pg_lsn` | √öltimo LSN que el cliente ha aplicado. |
| `write_lag` | `interval` | Diferencia entre `sent_lsn` y `write_lsn`. |
| `flush_lag` | `interval` | Diferencia entre `sent_lsn` y `flush_lsn`. |
| `replay_lag` | `interval` | Diferencia entre `sent_lsn` y `replay_lsn`. |
| `sync_priority` | `integer` | Prioridad de sincronizaci√≥n. |
| `sync_state` | `text` | Estado de sincronizaci√≥n: `async`, `sync`, `quorum`. |





